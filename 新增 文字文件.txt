<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¥µé™è“„åŠ›æ‹³æ“Š (AI å…¨é¢é€²åŒ–ç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #1a1a2e;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: manipulation;
        }
        canvas {
            background: linear-gradient(to bottom, #16213e, #0f3460);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 8px;
        }
        .btn-group {
            display: grid;
            gap: 8px;
            padding: 10px;
            max-width: 600px;
            margin: 0 auto;
        }
        .action-btn {
            padding: 12px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            user-select: none;
            border: 2px solid rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
        }
        .action-btn:active { transform: scale(0.95); }
        .action-btn:disabled { 
            opacity: 0.3; 
            cursor: not-allowed; 
            transform: none; 
            filter: grayscale(100%);
        }

        .btn-charge { background: #f1c40f; color: #000; }
        .btn-def { background: #3498db; color: white; }
        .btn-sdef { background: #8e44ad; color: white; border: 2px solid #f39c12; }
        .btn-atk { background: #e74c3c; color: white; }
        .btn-sk1 { background: #d35400; color: white; }
        .btn-sk2 { background: #c0392b; color: white; }
        .btn-sk3 { background: #2c3e50; color: #e74c3c; border: 2px solid #e74c3c; }
        
        .btn-restart {
            background: #27ae60;
            color: white;
            margin-top: 5px;
            border: 2px solid #2ecc71;
            font-size: 1rem;
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
            display: none; 
        }
        .btn-restart.show { display: block; animation: popIn 0.3s ease-out; }

        .btn-ai { 
            background: linear-gradient(45deg, #2196F3, #9C27B0); 
            color: white; 
            border: 1px solid rgba(255,255,255,0.5);
            box-shadow: 0 0 10px rgba(156, 39, 176, 0.5);
        }
        .btn-rival {
            background: linear-gradient(45deg, #FF5722, #FF9800);
            color: white;
            border: 1px solid rgba(255,255,255,0.5);
            box-shadow: 0 0 10px rgba(255, 87, 34, 0.5);
        }

        /* Commentator Box */
        #commentary-box {
            background: linear-gradient(90deg, #000000cc, #1a1a2ecc);
            border-left: 4px solid #f1c40f;
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            min-height: 50px;
            font-style: italic;
            color: #f1c40f;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            text-shadow: 1px 1px 2px black;
        }

        #battle-log {
            height: 60px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            padding: 8px;
            font-size: 0.85rem;
            font-family: monospace;
            border: 1px solid #333;
            margin-bottom: 5px;
        }
        .log-turn { color: #aaa; border-bottom: 1px solid #333; margin-top: 4px; padding-top: 4px; }
        .log-p { color: #64b5f6; } 
        .log-e { color: #e57373; } 
        .log-dmg { color: #ffeb3b; font-weight: bold; }
        .log-info { color: #81c784; }
        .log-ai { color: #E1BEE7; font-style: italic; }

        #turn-indicator {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        /* Taunt Bubble */
        .taunt-bubble {
            position: absolute;
            background: white;
            color: black;
            padding: 10px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 14px;
            max-width: 200px;
            top: 150px;
            right: 50px;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .taunt-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 20px;
            border-width: 10px 10px 0;
            border-style: solid;
            border-color: white transparent;
            display: block;
            width: 0;
        }
        
        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 5px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body class="h-screen flex flex-col justify-center items-center relative">

    <div id="game-ui" class="w-full flex flex-col items-center max-w-2xl px-2 relative">
        
        <!-- Taunt Bubble -->
        <div id="cpu-taunt" class="taunt-bubble">æ”¾é¦¬éä¾†ï¼</div>

        <div id="turn-indicator" class="text-white">æº–å‚™é–‹å§‹</div>
        
        <!-- AI Tools Area -->
        <div class="w-full flex gap-2 mb-2">
            <button id="btn-coach" class="action-btn btn-ai flex-1 text-center py-2 text-sm flex justify-center items-center" onclick="askCoach()">
                <span>âœ¨ æˆ°è¡“åˆ†æ</span>
            </button>
            <button id="btn-rival" class="action-btn btn-rival flex-1 text-center py-2 text-sm flex justify-center items-center" onclick="generateRival()">
                <span>ğŸ¦¹ ç”Ÿæˆæ–°å°æ‰‹</span>
            </button>
        </div>

        <!-- Canvas -->
        <canvas id="gameCanvas" width="800" height="400" class="w-full h-auto mb-2"></canvas>

        <!-- Commentary Box -->
        <div id="commentary-box" class="w-full">
            <span class="mr-2">ğŸ™ï¸</span>
            <span id="commentary-text">æ¯”è³½å³å°‡é–‹å§‹ï¼Œè§€çœ¾å±æ¯ä»¥å¾…...</span>
        </div>

        <!-- Battle Log -->
        <div id="battle-log" class="w-full"></div>

        <!-- Controls -->
        <div class="btn-group w-full">
            <div class="grid grid-cols-3 gap-2">
                <button class="action-btn btn-charge" id="btn-charge" onclick="startTurn('charge')">âš¡ è“„åŠ›</button>
                <button class="action-btn btn-def" id="btn-def" onclick="startTurn('block')">ğŸ›¡ï¸ é˜²å®ˆ</button>
                <button class="action-btn btn-sdef" id="btn-sdef" onclick="startTurn('superBlock')">ğŸ”° è¶…ç´šé˜²å®ˆ</button>
            </div>
            <div class="grid grid-cols-4 gap-2">
                <button class="action-btn btn-atk" id="btn-atk" onclick="startTurn('attack')">ğŸ‘Š æ™®æ”»</button>
                <button class="action-btn btn-sk1" id="btn-sk1" onclick="startTurn('skill1')">â‘  åˆºæ‹³</button>
                <button class="action-btn btn-sk2" id="btn-sk2" onclick="startTurn('skill2')">â‘¡ å‹¾æ‹³</button>
                <button class="action-btn btn-sk3" id="btn-sk3" onclick="startTurn('skill3')">â‘¢ å¿…æ®º</button>
            </div>
            
            <!-- RESTART BUTTON -->
            <button class="action-btn btn-restart" id="btn-restart" onclick="resetGame()">ğŸ”„ é‡æ–°é–‹å§‹éŠæˆ²</button>
        </div>
    </div>

<script>
/**
 * GEMINI API SETUP
 */
const apiKey = ""; 

async function callGemini(promptText, isJson = false) {
    if (!apiKey) {
        console.warn("API Key missing");
        return null;
    }
    
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
    
    // Add simple JSON structure hint if JSON is requested
    const finalPrompt = isJson 
        ? promptText + "\nè«‹ä»¥ç´” JSON æ ¼å¼å›å‚³ï¼Œä¸è¦åŒ…å« markdown æ¨™è¨˜ (```json)ã€‚" 
        : promptText;

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ parts: [{ text: finalPrompt }] }]
            })
        });

        if (!response.ok) throw new Error('API Error');
        const data = await response.json();
        let text = data.candidates?.[0]?.content?.parts?.[0]?.text || null;
        
        // Clean up markdown code blocks if Gemini adds them
        if (text && isJson) {
            text = text.replace(/```json/g, '').replace(/```/g, '').trim();
        }
        return text;
    } catch (error) {
        console.error("Gemini Error:", error);
        return null;
    }
}

/**
 * Game Config
 */
const CONFIG = {
    MAX_HP: 100,
    MAX_ENERGY: 3,
    DMG_BASIC: 5,
    DMG_S1: 12,
    DMG_S2: 25,
    DMG_S3: 40,
    COST_S1: 1,
    COST_S2: 2,
    COST_S3: 3
};

/**
 * State Management
 */
let gameState = {
    turn: 1,
    phase: 'player_input', 
    player: {
        hp: CONFIG.MAX_HP, energy: 0, action: null, status: 'idle', 
    },
    cpu: {
        hp: CONFIG.MAX_HP, energy: 0, action: null, status: 'idle',
    },
    cpuIdentity: {
        name: "è¨“ç·´æ©Ÿå™¨äºº",
        personality: "æ¨™æº–",
        desc: "ä¸€å€‹æ™®é€šçš„æ‹³æ“Šè¨“ç·´å°æ‰‹ã€‚"
    },
    lastEventDescription: "éŠæˆ²å‰›é–‹å§‹ã€‚"
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const logEl = document.getElementById('battle-log');
const turnEl = document.getElementById('turn-indicator');
const tauntEl = document.getElementById('cpu-taunt');
const coachBtn = document.getElementById('btn-coach');
const rivalBtn = document.getElementById('btn-rival');
const commTextEl = document.getElementById('commentary-text');
const restartBtn = document.getElementById('btn-restart');

// Floating text array
let floatingTexts = [];

/**
 * AI Features Implementation
 */

// 1. Coach
async function askCoach() {
    if (gameState.phase !== 'player_input') return;
    
    const originalText = coachBtn.innerHTML;
    coachBtn.innerHTML = `<span class="spinner"></span> åˆ†æ...`;
    coachBtn.disabled = true;

    const p = gameState.player;
    const c = gameState.cpu;
    
    const prompt = `
        ä½ æ˜¯ä¸€å€‹æ‹³æ“Šæ•™ç·´ã€‚æˆ°æ³ï¼š
        æˆ‘ï¼šHP ${p.hp}, èƒ½é‡ ${p.energy}/3ã€‚
        å°æ‰‹(${gameState.cpuIdentity.name})ï¼šHP ${c.hp}, èƒ½é‡ ${c.energy}/3ã€‚
        å°æ‰‹é¢¨æ ¼ï¼š${gameState.cpuIdentity.desc}ã€‚
        è«‹çµ¦ä¸€å€‹éå¸¸ç°¡çŸ­çš„ç¹é«”ä¸­æ–‡æˆ°è¡“å»ºè­°(20å­—å…§)ã€‚
    `;

    const advice = await callGemini(prompt);
    
    if (advice) {
        log(`ğŸ¤– æ•™ç·´: ${advice}`, "log-ai");
    } else {
        log(`ğŸ¤– æ•™ç·´: å°ˆå¿ƒçœ‹å°æ‰‹å‹•ä½œï¼`, "log-ai");
    }

    coachBtn.innerHTML = originalText;
    coachBtn.disabled = false;
}

// 2. Generate Rival
async function generateRival() {
    if (gameState.phase !== 'player_input') return;

    const originalText = rivalBtn.innerHTML;
    rivalBtn.innerHTML = `<span class="spinner"></span> ç”Ÿæˆä¸­...`;
    rivalBtn.disabled = true;

    const prompt = `
        è«‹å‰µé€ ä¸€å€‹ç¨ç‰¹çš„æ‹³æ“Šæ‰‹å°æ‰‹ã€‚
        å›å‚³ JSON æ ¼å¼ï¼š
        {
            "name": "ä¸­æ–‡åå­—(è­¬å¦‚ï¼šæš´æ€’æ³°æ£®)",
            "personality": "æ€§æ ¼æè¿°(è­¬å¦‚ï¼šå‚²æ…¢)",
            "desc": "ç°¡çŸ­çš„ä¸€å¥èƒŒæ™¯ä»‹ç´¹(è­¬å¦‚ï¼šä¾†è‡ªåœ°ä¸‹çš„é»‘æ‹³ç‹è€…)"
        }
    `;

    const text = await callGemini(prompt, true);
    if (text) {
        try {
            const data = JSON.parse(text);
            gameState.cpuIdentity = data;
            log(`--- æ–°æŒ‘æˆ°è€…ç™»å ´ ---`, "log-turn");
            log(`å°æ‰‹ï¼š${data.name}`, "log-ai");
            log(`ç‰¹å¾µï¼š${data.desc}`, "log-ai");
            commTextEl.innerText = `è§€çœ¾æ²¸é¨°äº†ï¼æ–°çš„æŒ‘æˆ°è€… ${data.name} è¸ä¸Šäº†æ“‚å°ï¼`;
            showTaunt(`æˆ‘æ˜¯${data.name}ï¼Œæº–å‚™å—æ­»å§ï¼`);
            
            // Visual feedback - full heal for fair fight if generating mid-game? 
            // Or just name change. Let's just change identity.
            updateUI();
        } catch (e) {
            console.error("JSON parse error", e);
        }
    }

    rivalBtn.innerHTML = originalText;
    rivalBtn.disabled = false;
}

// 3. Dynamic Taunt (Updated with Persona)
async function generateTaunt() {
    const p = gameState.player;
    const c = gameState.cpu;
    const id = gameState.cpuIdentity;
    const event = gameState.lastEventDescription;

    const prompt = `
        æ‰®æ¼”ä¸€å€‹æ‹³æ“Šæ‰‹ï¼š${id.name}ã€‚
        æ€§æ ¼ï¼š${id.personality}ã€‚
        èƒŒæ™¯ï¼š${id.desc}ã€‚
        ç›®å‰æˆ°æ³ï¼šæˆ‘æ–¹HP ${c.hp}, å°æ–¹HP ${p.hp}ã€‚
        å‰›å‰›ç™¼ç”Ÿçš„äº‹ï¼š${event}ã€‚
        è«‹æ ¹æ“šä½ çš„æ€§æ ¼è¬›ä¸€å¥ç°¡çŸ­çš„å˜²è«·æˆ–æŠ±æ€¨(ç¹é«”ä¸­æ–‡ï¼Œ15å­—å…§)ã€‚
    `;

    const taunt = await callGemini(prompt);
    if (taunt) {
        showTaunt(taunt);
    }
}

// 4. Live Commentary
async function generateCommentary(eventDescription) {
    const id = gameState.cpuIdentity;
    const prompt = `
        ä½ æ˜¯ä¸€å€‹ç†±è¡€çš„é«”è‚²ä¸»æ’­ã€‚
        æ­£åœ¨è½‰æ’­é€™å ´æ‹³æ“Šè³½ï¼šç©å®¶ vs ${id.name}ã€‚
        å‰›å‰›çš„å›åˆç™¼ç”Ÿäº†ï¼š${eventDescription}ã€‚
        è«‹ç”¨ä¸€å¥è©±(ç¹é«”ä¸­æ–‡ï¼Œ30å­—å…§)æ¿€å‹•åœ°æè¿°é€™å€‹ç•«é¢ã€‚
    `;
    
    // Don't await strictly to not block UI too long, update when ready
    callGemini(prompt).then(text => {
        if(text) {
            commTextEl.innerText = text;
            commTextEl.style.animation = 'none';
            commTextEl.offsetHeight; /* trigger reflow */
            commTextEl.style.animation = 'popIn 0.3s ease-out';
        }
    });
}

function showTaunt(text) {
    tauntEl.innerText = text;
    tauntEl.style.opacity = 1;
    setTimeout(() => {
        tauntEl.style.opacity = 0;
    }, 4000);
}

/**
 * Core Game Logic
 */

function resetGame() {
    gameState.turn = 1;
    gameState.phase = 'player_input';
    gameState.player = { hp: CONFIG.MAX_HP, energy: 0, status: 'idle', action: null };
    gameState.cpu = { hp: CONFIG.MAX_HP, energy: 0, status: 'idle', action: null };
    gameState.lastEventDescription = "éŠæˆ²é‡æ–°é–‹å§‹ã€‚";
    
    // Keep the generated rival identity!
    
    logEl.innerHTML = '';
    log("=== éŠæˆ²é‡æ–°é–‹å§‹ ===", "log-turn");
    commTextEl.innerText = "æ¯”è³½é‡æ–°é–‹å§‹ï¼é›™æ–¹å›åˆ°è§’è½æº–å‚™ã€‚";
    floatingTexts = [];
    tauntEl.style.opacity = 0;
    turnEl.innerText = "ä½ çš„å›åˆ";
    
    restartBtn.classList.remove('show');
    coachBtn.disabled = false;
    rivalBtn.disabled = false;
    
    updateUI();
}

async function startTurn(playerActionType) {
    if (gameState.phase !== 'player_input') return;

    let cost = 0;
    if (playerActionType === 'skill1') cost = 1;
    if (playerActionType === 'skill2') cost = 2;
    if (playerActionType === 'skill3') cost = 3;

    if (gameState.player.energy < cost) {
        log("èƒ½é‡ä¸è¶³ï¼ç„¡æ³•ä½¿ç”¨æ­¤æŠ€èƒ½ã€‚", "log-info");
        return;
    }

    // 1. Setup Player Action
    gameState.phase = 'animating';
    gameState.player.energy -= cost;
    gameState.player.action = playerActionType;
    coachBtn.disabled = true;
    rivalBtn.disabled = true;
    
    if (playerActionType === 'block') gameState.player.status = 'blocking';
    else if (playerActionType === 'superBlock') gameState.player.status = 'superBlocking';
    else if (playerActionType === 'charge') gameState.player.status = 'charging';
    else gameState.player.status = 'idle';

    updateUI(); 
    turnEl.innerText = "ç©å®¶è¡Œå‹•ä¸­...";
    
    // 2. CPU Decide
    const cpuActionType = decideCPUAction();
    gameState.cpu.action = cpuActionType;
    let cpuCost = 0;
    if (cpuActionType === 'skill1') cpuCost = 1;
    if (cpuActionType === 'skill2') cpuCost = 2;
    if (cpuActionType === 'skill3') cpuCost = 3;
    gameState.cpu.energy -= cpuCost;

    if (cpuActionType === 'block') gameState.cpu.status = 'blocking';
    else if (cpuActionType === 'superBlock') gameState.cpu.status = 'superBlocking';
    else if (cpuActionType === 'charge') gameState.cpu.status = 'charging';
    else gameState.cpu.status = 'idle';

    // 3. Resolve
    log(`--- ç¬¬ ${gameState.turn} å›åˆ ---`, "log-turn");
    const pResult = await performAction(true, gameState.player.action, gameState.cpu);
    if (checkGameOver()) return;

    turnEl.innerText = `${gameState.cpuIdentity.name} è¡Œå‹•ä¸­...`;
    await new Promise(r => setTimeout(r, 800));
    const cResult = await performAction(false, gameState.cpu.action, gameState.player);
    if (checkGameOver()) return;

    // 4. End Turn
    resolveEndTurn(true, gameState.player);
    resolveEndTurn(false, gameState.cpu);

    const eventDesc = `ç©å®¶ä½¿ç”¨${getActionName(gameState.player.action)}é€ æˆ${pResult}ï¼Œ${gameState.cpuIdentity.name}ä½¿ç”¨${getActionName(gameState.cpu.action)}é€ æˆ${cResult}`;
    gameState.lastEventDescription = eventDesc;
    
    // Trigger Commentary & Taunt
    generateCommentary(eventDesc);
    
    if (Math.random() < 0.6 || cResult.includes("å‚·å®³") || pResult.includes("å‚·å®³")) {
        generateTaunt();
    }

    // 5. Next Turn
    gameState.turn++;
    gameState.phase = 'player_input';
    turnEl.innerText = "ä½ çš„å›åˆ";
    updateUI();
    coachBtn.disabled = false;
    rivalBtn.disabled = false;
}

function getActionName(act) {
    const map = {
        'charge': 'è“„åŠ›', 'block': 'é˜²å®ˆ', 'superBlock': 'è¶…ç´šé˜²å®ˆ', 'attack': 'æ™®æ”»',
        'skill1': 'åˆºæ‹³', 'skill2': 'å‹¾æ‹³', 'skill3': 'å¿…æ®ºæŠ€'
    };
    return map[act] || act;
}

function decideCPUAction() {
    const p = gameState.player;
    const c = gameState.cpu;
    const rand = Math.random();

    if (p.status === 'charging' && c.energy >= 1) {
        if (c.energy >= 3 && rand < 0.8) return 'skill3'; 
        if (c.energy >= 2 && rand < 0.6) return 'skill2';
        return 'skill1';
    }
    if (c.energy === 3) {
        if (p.status === 'superBlocking') return 'charge'; 
        if (rand < 0.7) return 'skill3';
        return 'attack';
    }
    if (c.energy === 0) {
        if (rand < 0.4) return 'charge';
        if (rand < 0.8) return 'attack';
        return 'block';
    }
    if (c.energy >= 1) {
        if (p.hp < 20) return 'skill1'; 
        if (rand < 0.3) return 'charge';
        if (rand < 0.6) return 'skill1';
        return 'block';
    }
    return 'attack';
}

async function performAction(isPlayer, actionType, target) {
    const actor = isPlayer ? gameState.player : gameState.cpu;
    const name = isPlayer ? "ç©å®¶" : gameState.cpuIdentity.name;
    const targetName = isPlayer ? gameState.cpuIdentity.name : "ç©å®¶";
    const cssClass = isPlayer ? "log-p" : "log-e";

    actor.animState = 'attacking'; 
    if (['block','superBlock','charge'].includes(actionType)) actor.animState = actionType;
    
    let actionText = "";
    let damage = 0;
    let isSkill = false;
    let isUlt = false;

    switch(actionType) {
        case 'charge': actionText = "é–‹å§‹è“„åŠ›..."; break;
        case 'block': actionText = "èˆ‰èµ·é˜²å®ˆ"; break;
        case 'superBlock': actionText = "é–‹å•Ÿè¶…ç´šé˜²å®ˆ"; break;
        case 'attack': actionText = "æ“Šå‡ºåˆºæ‹³"; damage = CONFIG.DMG_BASIC; break;
        case 'skill1': actionText = "ä½¿å‡º [æŠ€èƒ½1: é€£æ“Š]"; damage = CONFIG.DMG_S1; isSkill = true; break;
        case 'skill2': actionText = "ä½¿å‡º [æŠ€èƒ½2: é‡å‹¾æ‹³]"; damage = CONFIG.DMG_S2; isSkill = true; break;
        case 'skill3': actionText = "ä½¿å‡º [æŠ€èƒ½3: å¿…æ®ºä¸Šå‹¾æ‹³]"; damage = CONFIG.DMG_S3; isSkill = true; isUlt = true; break;
    }

    log(`${name} ${actionText}`, cssClass);
    await new Promise(r => setTimeout(r, 500)); 

    let resultString = "ç„¡æ•ˆæœ";

    if (damage > 0) {
        let finalDmg = damage;
        let blocked = false;
        let blockMsg = "";

        if (target.status === 'superBlocking') {
            finalDmg = 0;
            blocked = true;
            blockMsg = "å®Œç¾é˜²ç¦¦ï¼";
        } else if (target.status === 'blocking') {
            if (isUlt) blockMsg = "é˜²å®ˆè¢«è²«ç©¿ï¼"; 
            else {
                finalDmg = 0;
                blocked = true;
                blockMsg = "æ ¼æ“‹æˆåŠŸï¼";
            }
        }

        if (blocked) {
            log(`...è¢« ${targetName} ${blockMsg}`, "log-info");
            addFloatingText(target, blockMsg, "#3498db");
            resultString = "è¢«æ ¼æ“‹";
        } else {
            target.hp = Math.max(0, target.hp - finalDmg);
            log(`...é€ æˆ ${finalDmg} å‚·å®³!`, "log-dmg");
            addFloatingText(target, `-${finalDmg}`, "#e74c3c");
            target.animState = 'hit'; 
            resultString = `${finalDmg}å‚·å®³`;
            
            if (target.status === 'charging') {
                if (isSkill) {
                    target.status = 'idle'; 
                    log(`!!! ${targetName} çš„è“„åŠ›è¢«æ‰“æ–·äº†ï¼`, "log-dmg");
                    addFloatingText(target, "æ‰“æ–·!", "#ff0000");
                    resultString += "(æ‰“æ–·è“„åŠ›)";
                } else {
                    log(`...${targetName} ç¡¬æ‰›ä¸‹æ”»æ“Šç¹¼çºŒè“„åŠ›`, "log-info");
                    addFloatingText(target, "ç¡¬æ‰›", "#aaaaaa");
                }
            }
        }
    } else {
        resultString = "";
    }
    
    setTimeout(() => {
        actor.animState = actor.status; 
        target.animState = target.status;
    }, 400);

    await new Promise(r => setTimeout(r, 600)); 
    return resultString;
}

function resolveEndTurn(isPlayer, actor) {
    const name = isPlayer ? "ç©å®¶" : gameState.cpuIdentity.name;
    if (actor.status === 'charging') {
        if (actor.energy < CONFIG.MAX_ENERGY) {
            actor.energy++;
            log(`${name} è“„åŠ›å®Œæˆï¼èƒ½é‡ +1`, "log-info");
            addFloatingText(actor, "+1 èƒ½é‡", "#f1c40f");
        }
    }
    actor.status = 'idle';
    actor.animState = 'idle';
}

function checkGameOver() {
    if (gameState.player.hp <= 0 || gameState.cpu.hp <= 0) {
        gameState.phase = 'game_over';
        let winner = gameState.player.hp > 0 ? "ç©å®¶" : gameState.cpuIdentity.name;
        turnEl.innerText = `${winner} ç²å‹ï¼`;
        log(`éŠæˆ²çµæŸï¼ ${winner} ç²å‹`, "log-dmg");
        updateUI();
        
        restartBtn.classList.add('show');
        coachBtn.disabled = true;
        rivalBtn.disabled = true;
        
        // Final Taunt
        const prompt = `
            éŠæˆ²çµæŸã€‚${winner}ç²å‹ã€‚
            æˆ‘æ˜¯${gameState.cpuIdentity.name}ï¼Œæ€§æ ¼${gameState.cpuIdentity.personality}ã€‚
            å¦‚æœæˆ‘è¼¸äº†ï¼Œè¬›ä¸€å¥ä¸ç”˜å¿ƒçš„è©±ã€‚å¦‚æœæˆ‘è´äº†ï¼Œè¬›ä¸€å¥å‹åˆ©æ„Ÿè¨€ã€‚
        `;
        callGemini(prompt).then(res => {
            if(res) showTaunt(res);
        });

        // Final Commentary
        const commPrompt = `æ¯”è³½çµæŸï¼${winner}ç²å¾—äº†å‹åˆ©ï¼è«‹ç‚ºé€™å ´ç²¾å½©çš„æ‹³æ“Šè³½åšä¸€å¥çµå°¾è¬›è©•ã€‚`;
        generateCommentary(commPrompt);

        return true;
    }
    return false;
}

function log(msg, cls) {
    const div = document.createElement('div');
    div.innerText = msg;
    if (cls) div.className = cls;
    logEl.appendChild(div);
    logEl.scrollTop = logEl.scrollHeight;
}

function addFloatingText(target, text, color) {
    let x = (target === gameState.player) ? 200 : 600;
    let y = 200;
    
    floatingTexts.push({
        x: x, y: y, text: text, color: color, life: 60, vy: -1
    });
}

function updateUI() {
    const p = gameState.player;
    const isTurn = gameState.phase === 'player_input';

    document.getElementById('btn-charge').disabled = !isTurn;
    document.getElementById('btn-def').disabled = !isTurn;
    document.getElementById('btn-sdef').disabled = !isTurn;
    
    const atkBtns = ['btn-atk', 'btn-sk1', 'btn-sk2', 'btn-sk3'];
    atkBtns.forEach(id => {
        let btn = document.getElementById(id);
        btn.disabled = !isTurn;
        if (id === 'btn-sk1' && p.energy < 1) btn.disabled = true;
        if (id === 'btn-sk2' && p.energy < 2) btn.disabled = true;
        if (id === 'btn-sk3' && p.energy < 3) btn.disabled = true;
    });
}

/**
 * Rendering Loop
 */
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Floor
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 350, 800, 50);

    drawFighter(true, gameState.player);
    drawFighter(false, gameState.cpu);
    drawHUD();
    drawFloating();

    requestAnimationFrame(draw);
}

function drawFighter(isPlayer, data) {
    ctx.save();
    let x = isPlayer ? 200 : 600;
    let y = 280;
    let color = isPlayer ? '#3498db' : '#e74c3c';
    
    let state = data.animState || data.status;

    if (state === 'hit') {
        x += (Math.random() - 0.5) * 10;
        y += (Math.random() - 0.5) * 10;
        color = '#fff'; 
    }

    if (state === 'attacking') {
        x += isPlayer ? 50 : -50;
    }

    if (!isPlayer) {
        ctx.translate(x, y);
        ctx.scale(-1, 1);
        ctx.translate(-x, -y);
    }

    // Body
    ctx.fillStyle = color;
    if (state === 'charging') ctx.fillStyle = '#f1c40f'; 
    ctx.fillRect(x - 20, y - 60, 40, 80);

    // Head
    ctx.beginPath();
    ctx.arc(x, y - 80, 25, 0, Math.PI * 2);
    ctx.fill();

    // Icons
    if (state === 'charging') {
        ctx.font = "20px Arial";
        ctx.fillStyle = "#f1c40f";
        ctx.fillText("âš¡", x - 10, y - 120);
    }
    if (state === 'blocking') {
        ctx.font = "20px Arial";
        ctx.fillStyle = "#3498db";
        ctx.fillText("ğŸ›¡ï¸", x - 10, y - 120);
    }
    if (state === 'superBlocking') {
        ctx.font = "20px Arial";
        ctx.fillStyle = "#8e44ad";
        ctx.fillText("ğŸ”°", x - 10, y - 120);
    }

    // Arms
    ctx.fillStyle = isPlayer ? '#e67e22' : '#c0392b';
    
    if (['blocking', 'superBlocking'].includes(state)) {
        ctx.fillRect(x + 10, y - 70, 20, 60);
    } else if (state === 'attacking') {
        ctx.beginPath();
        ctx.arc(x + 60, y - 50, 20, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = color;
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.moveTo(x, y - 50);
        ctx.lineTo(x + 60, y - 50);
        ctx.stroke();
    } else {
        ctx.beginPath();
        ctx.arc(x + 25, y - 40, 15, 0, Math.PI*2);
        ctx.fill();
    }

    // Legs
    ctx.strokeStyle = color;
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.moveTo(x - 10, y + 20);
    ctx.lineTo(x - 20, y + 70);
    ctx.moveTo(x + 10, y + 20);
    ctx.lineTo(x + 20, y + 70);
    ctx.stroke();

    ctx.restore();
}

function drawHUD() {
    drawBar(20, 20, 250, 20, gameState.player.hp, CONFIG.MAX_HP, '#3498db');
    drawEnergy(20, 50, gameState.player.energy);
    ctx.fillStyle = '#fff';
    ctx.font = '16px Arial';
    ctx.fillText(`HP: ${gameState.player.hp}`, 20, 40);

    drawBar(530, 20, 250, 20, gameState.cpu.hp, CONFIG.MAX_HP, '#e74c3c');
    drawEnergy(530, 50, gameState.cpu.energy);
    ctx.fillText(`${gameState.cpuIdentity.name}: ${gameState.cpu.hp}`, 530, 40);
}

function drawBar(x, y, w, h, val, max, color) {
    ctx.fillStyle = '#333';
    ctx.fillRect(x, y, w, h);
    ctx.fillStyle = color;
    ctx.fillRect(x, y, (val/max)*w, h);
    ctx.strokeStyle = '#fff';
    ctx.strokeRect(x, y, w, h);
}

function drawEnergy(x, y, val) {
    for(let i=0; i<3; i++) {
        ctx.beginPath();
        ctx.arc(x + 15 + i*30, y, 10, 0, Math.PI*2);
        if (i < val) {
            ctx.fillStyle = '#f1c40f';
            ctx.fill();
        } else {
            ctx.strokeStyle = '#666';
            ctx.stroke();
        }
    }
}

function drawFloating() {
    for(let i=floatingTexts.length-1; i>=0; i--) {
        let f = floatingTexts[i];
        ctx.fillStyle = f.color;
        ctx.font = "bold 20px Arial";
        ctx.fillText(f.text, f.x, f.y);
        f.y += f.vy;
        f.life--;
        if(f.life <= 0) floatingTexts.splice(i, 1);
    }
}

// Start
requestAnimationFrame(draw);
updateUI();
</script>
</body>
</html>